u
Tasks :

    -How to install rabbitmq as a service (on windows)
    -Get rabbitmq running 
    -Testing the different methods in c# 
        =single producer-consumer;
        -multiple producer-consumer;
        =routing
        =topics
        ! No RTC
    -Use multiple small command line applikations (microservice approach)
    -What data can we store in rabbitmq (json, xml, SLY might say bjson)
    -How is performance in general (how fast can we push and pull data to rabbitmq)
    -How does persitance work (no data loss on server reboots)
    -Scaled out functionality of Rabbitmq (cluster / more than one server). How to connect to the service with multiple from c#


I. Insalling rabbit mq

    1. Download the server (https://www.rabbitmq.com/install-windows.html)
    2. Download latest earlangOTP (http://www.erlang.org/downloads), I am using the 64-bit


    3. Uninstall previous vesions installed.
        
        -If you have an existing installation and are planning to upgrade the Erlang VM from a 32bit to a 64bit version then you 
        must uninstall the broker before upgrading the VM. The installer will not be able to stop or remove a service that was 
        installed with an Erlang VM of a different architecture.

    Note! : The service will run fine using its default settings. You may want to customise the RabbitMQ environment or edit configuration.
    Note! : The RabbitMQ service starts automatically. You can stop/reinstall/start the RabbitMQ service from the Start Menu.
    Note! : You can find links to RabbitMQ directories in the Start Menu. There is also a link to a command prompt window that will 
    start in the sbin dir, in the Start Menu. This is the most convenient way to run the various command line tools.
    
    4. Install server 
        4.1 Install latest Erlang from (step2).
        4.2 Install rabbitMq server from (step1)

    5. Make sure the followind ports are open. If the ports are not available then RabbitMq will not start.
    4369 (epmd), 25672 (Erlang distribution)
    5672, 5671 (AMQP 0-9-1 without and with TLS)
    15672 (if management plugin is enabled)
    61613, 61614 (if STOMP is enabled)
    1883, 8883 (if MQTT is enabled)

    6. When starting Rabbitmqctl.bat a broker creates a user "guest" with password "guest"
    These credentials are only used when connecting to the broker as localhost. From other machines these
    credentials need to be changed before any action can be taken.

    7. Rabbitmqctl.bat manages the broker. Use --help for any information.

    8. Output from the server is sent to a RABBITMQ_NODENAME.log file in the RABBITMQ_LOG_BASE directory.
    Additional log data is written to RABBITMQ_NODENAME-sasl.log.
    The broker always appends to the log files, so a complete log history is retained. You can rotate logs using rabbitmqctl rotate_logs.

    9. n the event that the Erlang VM crashes whilst RabbitMQ is running as a service, rather than writing the crash dump to the current 
    directory (which doesn't make sense for a service) it is written to an erl_crash.dump file in the base directory of the RabbitMQ server 
    (set by the RABBITMQ_BASE environment variable, defaulting to %APPDATA%\%RABBITMQ_SERVICENAME% - typically %APPDATA%\RabbitMQ otherwise).

    10. There can be windows specific issues so for this reason visit https://www.rabbitmq.com/windows-quirks.html
    or at the RabbitMq mailing list https://groups.google.com/forum/#!forum/rabbitmq-users


    Notes while running rabbitMq:

    -By default multiple, when serving multiple clients the rabbitMq system uses Round-robin dispatching

    -Forgotten acknowledgment :
        It's a common mistake to miss the BasicAck. It's an easy error, but the consequences are serious. Messages
        will be redelivered when your client quits (which may look like random redelivery), but RabbitMQ will eat
        more and more memory as it won't be able to release any unacked messages.
        In order to debug this kind of mistake you can use rabbitmqctl to print the messages_unacknowledged field:
        $ sudo rabbitmqctl list_queues name messages_ready messages_unacknowledged
                Listing queues ...
                hello    0       0
                ...done.
    
    Prevent data loss if receiver dies:
    -By default Recievers send a acknowledgment to the Sender after the message was received and proccesed
    so that the rabbitMq is free to delete the message

    Prevent data loss if server dies:
    - Declare durable queues:
        channel.QueueDeclare(queue: "task_queue",
                     durable: true,
                     exclusive: false,
                     autoDelete: false,
                     arguments: null);
        
    !!!! RabbitMQ does not allow redeclaration of a queue with the same name. Example above will not work 
    because I already declared a non durable queue called "task_queue". Work around is to make a
    different called queue

    !!!! Marking messages as persistent doesn't fully guarantee that a message won't be lost. Although it
    tells RabbitMQ to save the message to disk, there is still a short time window when RabbitMQ has 
    accepted a message and hasn't saved it yet. Also, RabbitMQ doesn't do fsync(2) for every message
    -- it may be just saved to cache and not really written to the disk. The persistence guarantees
    aren't strong, but it's more than enough for our simple task queue. If you need a stronger guarantee
    then you can use publisher confirms.

    Fair dispatching:
        -channelBasicQos(0,1,false); - This goes in the Receiver code

        -Prevents the queue from dispatching a message to a receiver if the receiver is still processing
        a previous message.
        -This can help with load balanging. Prevents a receiver from beeing overloaded with messages.
        -Can run out of memory if a lot of messages take long to resolve.   



Documentation notes:

TLS/SSL support :

-built in support for TLS (client connections and pupular plugins such as Federation Links)
-can use TLS to encrypt inter node comunication in cluster

Troubleshooting TLS-related issues :https://www.rabbitmq.com/troubleshooting-ssl.html

- to support TLS connections, rmq needs TLS and crypto-related modules to be available in  the Earlang/OTP
- recomended Erlang/OTP version to use with tls is 18.2.
- R16B03 may work with some certificates but has limitations

-The Erlang crypto, asn1, public_key, and ssl libraries (applications) must be installed and functional.
 On Debian and Ubuntu this is provided by the erlang-ssl package. The zero dependency Erlang RPM for RabbitMQ includes the above modules.

-if erlang/otp compiled from source, make sure that "configure" finds OpenSSL

-if ECC cipher suites is expected, use Erlang/otp 19.x , earlyer versions have issues with it

-if you have winxp.... rip


Persistance configuration :
    -Persistence / transient , both can be written to disk
    -Persisted messages will be written to disk as soon as they reach the queue
    -Transient messages will be written to disk only so they can be evicted from memmory
    -Persistance layer referes to both types

    Persistance layer :
        -queue index 
            - responsible with maintaining knowledge about where a given msg is in the queue
            - whether it has been delivered and aknowledges
        -message store
            -key-value store for messages shared among all queues
            -messages can be written to the message store or directly to the queue index
        
--------------More to it on the site docs -----------------------


Management plugin : 

-rabbitmq-management plugin provides an http-based api for managing and monitoring the RabbitMq server

-sample rates can be modified , default is 5000ms sampling, performance is ofcourse hindered when larger sample rates
-management plugin is aware of clusters and can present data accordingly
-can connect to each node on port 15672 to acces the management UI. If we want to acces the data but not bloat each node , rabbitmq-management-agent is required
-statistics database stored entirely in memory

Clustering:

- Erlang VM runs rabbitMq
- Each rabbitMq node represents a processing
- Multiple processes can run on one machine, however ErlangVM runs a single process so all the 
- All nodes connected to cluster behave as a singularity. It's ok for nodes to crash. If they do
    , the rest of the node continues as if nothing happened. The other node can be restarted and 
    will catch up with the cluster.

- When the cluster goes down, the last node to go offline, must be the first node to come online.
If this does not happen, the cluster waits 30 seconds for the last disc node to come online.

- If the node can not be broght back online it can be removed from the cluster with the forget_cluster_node
command

- If shit goes haywire and all nodes shot down at the same time (i.e. power outtage) every node will think 
that some other node was the last to go out. In this case, we can use the force_boot command on one node to
make it bootable again.

- When configuring clusters it is important to have all cookies match on the nodes. Each machine runing rabbit mq has
two cookies, one located in "%USER%/.erlang.cookie" and one located in "Windows/.erlang.cookie"

Production checklist:
    Virtual Hosts: 
        -single tenant environment : default virtual host(/)
        -multiple projects will need individual virtual Hosts
    
    Users:
        -for production environments delete the default user
        -"guest" user can only connect from the localhost by default
        
        -when using multiple applications it is best to use individual users :
            -correlating client connections with applications
            -using fine-grained permissions 
            -credentials roll-over (e.g. periodically or in case of a breach)
        
    Memory: default uses up to 40% available RAM
        -At least 128 MB
        -75% of the configured RAM limit when the limit is up to 4 GB of RAM
        -80% of the configured RAM limit when the limit is between 4 and 8 GB of RAM
        -85% of the configured RAM limit when the limit is between 8 and 16 GB of RAM
        -90% of the configured RAM limit when the limit is above 16 GB of RAM
        -above 90% is a dangerous instable zone

    Disk space: default requires 50mb at all times
        -At least 2 GB
        -50% of the configured RAM limit when the limit is between 1 and 8 GB of RAM 
        -40% of the configured RAM limit when the limit is between 8 and 32 GB of RAM
        -30% of the configured RAM limit when the limit is above 32 GB of RAM    
    
Notes : 

- Docker encapsulates process
- In Docker, ErlangVM runs RabbitMQ
- Erlang will use all the resources at it's disposal so unless there is one instance of RabbitMQ on each machine,
it is best to run each broker into one Docker

Performance Tests:

https://www.rabbitmq.com/blog/2012/04/17/rabbitmq-performance-measurements-part-1/
https://www.rabbitmq.com/blog/2012/04/25/rabbitmq-performance-measurements-part-2/


Test server rack : PowerEdge R610 with Dual Xeon E5530's and 40GB Ram
   - Xeon E5530 : 8M cache, 2,40 GHZ, 5,86 gt/s
 

Benchmarks :


1Consumer - 1Producer :
    - auto-ack: 44000 10bytemsg/sec
    - mandatory: 22400 10bytemsg/sec
    - immediate: 22000 10bytemsg/sec
    - ack : 32000 10bytemsg/sec
    - ack-confirm: 26000 10bytemsg/sec
    - a-c-persist: 4700 10bytemsg/sec

- no-consume, 1Producer : 53000 1bytemsg/s


- using 2 cores on the rack and paralel producers with no consumption : 150000 msg/s
    - publishing to large number of consumers in paralel: 64000 msg/s